"""
File operations for the text_editor plugin.

Split into two layers:
  - _impl functions in python/helpers/rfc_text_editor.py: pure filesystem
    I/O with only stdlib deps. These run inside the Docker container
    when routed via RFC.
  - Public async functions here: orchestrate _impl calls through
    runtime.call_development_function and apply token budgeting
    (which requires tiktoken, a framework-only dependency).
"""

from dataclasses import dataclass

from python.helpers import tokens, runtime
from python.helpers.rfc_text_editor import (
    is_binary_impl as _is_binary_impl,
    read_file_raw_impl as _read_file_raw_impl,
    write_file_impl as _write_file_impl,
    apply_patch_impl as _apply_patch_impl,
    file_info_impl as _file_info_impl,
)

# ------------------------------------------------------------------
# Binary detection
# ------------------------------------------------------------------

async def is_binary(path: str) -> bool:
    """Detect binary file by checking for null bytes."""
    return await runtime.call_development_function(_is_binary_impl, path)


# ------------------------------------------------------------------
# File metadata
# ------------------------------------------------------------------

async def file_info(path: str) -> dict:
    """
    Get file metadata from the container.

    Returns dict with: exists, is_file, realpath, expanded, mtime.
    """
    return await runtime.call_development_function(_file_info_impl, path)


# ------------------------------------------------------------------
# Read
# ------------------------------------------------------------------

@dataclass
class ReadResult:
    content: str = ""
    total_lines: int = 0
    warnings: str = ""
    error: str = ""


async def read_file(
    path: str,
    line_from: int = 1,
    line_to: int | None = None,
    max_line_tokens: int = 500,
    default_line_count: int = 100,
    max_total_read_tokens: int = 4000,
) -> ReadResult:
    """
    Read a text file and return numbered lines with token budgeting.

    Line numbers are 1-based (matching grep, sed, editors).
    line_from and line_to are both inclusive.
    None line_to defaults to line_from + default_line_count - 1.
    """
    # I/O happens in the container via RFC; token budgeting stays host-side.
    raw = await runtime.call_development_function(_read_file_raw_impl, path)

    if raw["error"]:
        return ReadResult(error=raw["error"])

    all_lines = raw["lines"]
    total_lines = raw["total_lines"]

    line_from = max(line_from, 1)
    if line_to is None:
        line_to = line_from + default_line_count - 1
    line_to = min(line_to, total_lines)

    # Convert 1-based inclusive range to 0-based slice
    idx_from = line_from - 1
    idx_to = line_to  # slice is exclusive, line_to is inclusive 1-based
    selected = all_lines[idx_from:idx_to]
    num_width = len(str(line_to))

    warn_parts: list[str] = []
    cropped_lines: list[int] = []
    output_lines: list[str] = []
    running_tokens = 0
    trimmed_by_total = False

    for i, raw_line in enumerate(selected):
        line_no = line_from + i  # 1-based
        stripped = raw_line.rstrip("\n").rstrip("\r")
        line_tok = tokens.count_tokens(stripped)

        if line_tok > max_line_tokens:
            chars_per_tok = max(len(stripped) / line_tok, 1)
            keep_chars = int(max_line_tokens * chars_per_tok * tokens.TRIM_BUFFER)
            stripped = stripped[:keep_chars] + "..."
            cropped_lines.append(line_no)
            line_tok = max_line_tokens

        if running_tokens + line_tok > max_total_read_tokens:
            trimmed_by_total = True
            break

        running_tokens += line_tok
        output_lines.append(f"{line_no:>{num_width}} {stripped}")

    if cropped_lines:
        nums = " ".join(str(n) for n in cropped_lines)
        warn_parts.append(
            f"long lines {nums} cropped - use terminal for precise manipulation"
        )
    if trimmed_by_total:
        actual_end = line_from + len(output_lines)
        warn_parts.append(
            f"output trimmed at line {actual_end} due to token limit"
            " - use line_from/line_to for remaining"
        )

    warn_str = ""
    if warn_parts:
        warn_str = "\nwarning: " + "; ".join(warn_parts)

    return ReadResult(
        content="\n".join(output_lines),
        total_lines=total_lines,
        warnings=warn_str,
    )


# ------------------------------------------------------------------
# Write
# ------------------------------------------------------------------

@dataclass
class WriteResult:
    total_lines: int = 0
    error: str = ""


async def write_file(path: str, content: str | None) -> WriteResult:
    """Create or overwrite a file."""
    if content is None:
        content = ""
    result = await runtime.call_development_function(
        _write_file_impl, path, content
    )
    if result["error"]:
        return WriteResult(error=result["error"])
    return WriteResult(total_lines=result["total_lines"])


# ------------------------------------------------------------------
# Patch
# ------------------------------------------------------------------

@dataclass
class PatchResult:
    total_lines: int = 0
    edit_count: int = 0
    error: str = ""


def validate_edits(edits: list | None) -> tuple[list[dict], str]:
    """
    Normalise and validate an edits array.

    Line numbers are 1-based (matching grep, sed, editors).
    Semantics (to is inclusive):
      {from:2, to:2, content:"x\\n"} - replace line 2
      {from:1, to:3, content:"x\\n"} - replace lines 1-3
      {from:2, to:2}                 - delete line 2
      {from:5}  or {from:5, to:-1}   - insert before line 5 (no deletion)

    Returns (parsed_edits, error_string). error_string is empty on success.
    """
    if not edits or not isinstance(edits, list):
        return [], "edits array is required"

    parsed: list[dict] = []
    for e in edits:
        if not isinstance(e, dict):
            return [], f"invalid edit entry: {e}"
        frm = int(e.get("from", 0))
        if frm < 1:
            return [], f"edit missing or invalid from (must be >= 1): {e}"
        # to == -1 or absent means pure insert (no lines removed)
        to = int(e.get("to", -1))
        is_insert = to < 0 or to < frm
        if is_insert:
            to = frm - 1  # normalise: marks zero-width range
        parsed.append({
            "from": frm,
            "to": to,
            "content": e.get("content", ""),
            "insert": is_insert,
        })

    parsed.sort(key=lambda x: (x["from"], 0 if x["insert"] else 1))
    for i in range(1, len(parsed)):
        prev, cur = parsed[i - 1], parsed[i]
        # Inserts at the same line don't overlap with each other or
        # with a replace that starts at the same line.
        if prev["insert"]:
            continue
        # prev is a replace/delete: its range is [from..to] inclusive
        if cur["from"] <= prev["to"]:
            return [], (
                f"overlapping edits: edit at {prev['from']}"
                f" (to {prev['to']}) and {cur['from']}"
                f" (to {cur['to']})"
            )

    return parsed, ""


async def apply_patch(path: str, edits: list[dict]) -> int:
    """
    Apply sorted, validated edits by streaming to a temp file.

    Line numbers are 1-based. Edits use inclusive 'to'.
    Inserts have 'insert': True.
    Returns total line count after patching.
    """
    result = await runtime.call_development_function(
        _apply_patch_impl, path, edits
    )
    if result["error"]:
        raise Exception(result["error"])
    return result["total_lines"]


async def patch_file(path: str, edits: list | None) -> PatchResult:
    """Validate and apply edits to a file."""
    info = await runtime.call_development_function(
        _file_info_impl, path
    )
    if not info["is_file"]:
        return PatchResult(error="file not found")

    parsed, err = validate_edits(edits)
    if err:
        return PatchResult(error=err)

    try:
        total = await apply_patch(info["expanded"], parsed)
    except Exception as exc:
        return PatchResult(error=str(exc))

    return PatchResult(total_lines=total, edit_count=len(parsed))
